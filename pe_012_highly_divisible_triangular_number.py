from functools import reduce
from math import sqrt
from typing import Tuple, Iterable
from pe_000_utils import timed, print_answers

# == Project Euler: Problem 12 ======================================================================================= #

"""
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
"""

# == Solution 1 ====================================================================================================== #


def next_candidate() -> Iterable:
    number = 9

    while True:

        if number % 10 == 3:
            number += 4

        else:
            number += 2

        yield number


def get_primes(quantity: int) -> Tuple:
    primes = [2, 3, 5, 7]

    for number in next_candidate():
        is_prime = True

        for divisor in primes:

            if divisor > sqrt(number) + 1:
                break

            if not number % divisor:
                is_prime = False
                break

        if is_prime:
            primes.append(number)

        if len(primes) == quantity:
            return tuple(primes)


def get_next_prime(primes: Tuple) -> Tuple:

    for number in next_candidate():
        is_prime = True

        for divisor in primes:

            if divisor > sqrt(number) + 1:
                break

            if not number % divisor:
                is_prime = False
                break

        if is_prime:
            return primes + (number, )


def get_factors(number: int, primes: Tuple[int]) -> Tuple:
    factors = []

    for divisor in primes:

        if divisor > number:
            break

        if not number % divisor:
            exponent = 1
            number //= divisor

            while not number % divisor:
                exponent += 1
                number //= divisor

            factors.append(exponent)

    return tuple(factors)


@timed
def solution_1(min_divisors=500):
    primes = get_primes(500)
    number = 0

    while True:
        number += 1
        current_divisors = 1

        for exponent in get_factors(number * (number + 1) // 2, primes):
            current_divisors *= exponent + 1

        if current_divisors > min_divisors:
            return number * (number + 1) // 2


if __name__ == '__main__':
    print(solution_1(500))

