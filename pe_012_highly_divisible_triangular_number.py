from functools import reduce
from math import sqrt
from typing import Tuple, Iterable
from pe_000_utils import timed, print_answers

# == Project Euler: Problem 12 ======================================================================================= #

"""
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
"""

# == Common Code ===================================================================================================== #


def next_candidate() -> Iterable:
    number = 9

    while True:

        if number % 10 == 3:
            number += 4

        else:
            number += 2

        yield number


def get_primes(quantity: int) -> Tuple:
    primes = [2, 3, 5, 7]

    for number in next_candidate():
        is_prime = True

        for divisor in primes:

            if divisor > sqrt(number) + 1:
                break

            if not number % divisor:
                is_prime = False
                break

        if is_prime:
            primes.append(number)

        if len(primes) == quantity:
            return tuple(primes)


def get_next_prime(primes: Tuple) -> Tuple:

    for number in next_candidate():
        is_prime = True

        for divisor in primes:

            if divisor > sqrt(number) + 1:
                break

            if not number % divisor:
                is_prime = False
                break

        if is_prime:
            return primes + (number, )


def get_factors(number: int, primes: Tuple[int]) -> Tuple:
    factors = []

    for divisor in primes:

        if divisor > number:
            break

        if not number % divisor:
            exponent = 1
            number //= divisor

            while not number % divisor:
                exponent += 1
                number //= divisor

            factors.append(exponent)

    return tuple(factors)

# == Solution 1 ====================================================================================================== #


@timed
def solution_1(min_divisors=500):
    """
    This solution uses prime factorization and the fact that a triangular number is given by k * (k + 1) / 2, where k
    k + 1 are coprime to reuse the divisors of k + 1 in the next iteration of the algorithm

    :param min_divisors:
    :return:
    """

    primes = get_primes(500)
    current_divisors = 1
    previous_divisors = 1
    index = 1

    while previous_divisors * current_divisors < min_divisors:
        index += 1
        number = index + 1
        previous_divisors = current_divisors
        current_divisors = 1

        if not number % 2:
            number //= 2

        for exponent in get_factors(number, primes):
            current_divisors *= exponent + 1

    return index * (index + 1) // 2


# == Solution 2 ====================================================================================================== #


@timed
def solution_2(min_divisors=500):
    """
    This solution uses prime factorization to find the divisors of a triangular number

    :param min_divisors:
    :return:
    """

    primes = get_primes(500)
    current_divisors = 1
    index = 1

    while current_divisors < min_divisors:
        index += 1
        current_divisors = 1
        number = (index + 1) * index // 2

        for exponent in get_factors(number, primes):
            current_divisors *= exponent + 1

    return index * (index + 1) // 2


if __name__ == '__main__':
    print_answers('Highly Divisible Triangular Numbers', solution_1, solution_2, params=(500,))

